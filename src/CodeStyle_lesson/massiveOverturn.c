#include <stdio.h>
#include <stdlib.h>

/* Суть алгоритма такая: берется элемент, стоящий на нулевом индексе в списке, заносится в отдельную переменную.
 * Далее отдельным циклом все элементы кроме нулевого смещаются на одну позицию влево.
 * В конце этого цикла переменная, с элементом, который мы запомнили в начале, ставится на последнюю позицию.
 * И делается это все ровно m раз.
 * Для наглядности, что алгоритм работает, я заполнила его натуральными числами, упорядоченными по возрастанию.
 * если у нас было [1, 2, 3, 4, 5] и m = 3 n = 2, то в конце программы список примет вид [4, 5, 1, 2, 3],
 * то есть конец поменялся с началом.
 */

int main()
{
    int n = 0; // длина конца
    int m = 0; // длина начала
    scanf("%d %d", &n, &m); // я так поняла, что пользователь сам вводит длину массива

    int *list = calloc(n+m, sizeof(int));
    for (int i = 0; i < m + n; i++) {
        list[i] = i + 1; // заполняем массив значениями, чтобы в нем хранилось что-то упорядоченное, для наглядности, что нужный порядок сохраняется
    }
    int fromBeginingToEnd = 0;
    for (int i = 0; i < m; i++) {
        fromBeginingToEnd = list[0];
        for (int j = 1; j <= m + n - 1; j++) {
            list[j - 1] = list[j];
        }
        list[m + n - 1] = fromBeginingToEnd;
    }
    int a = 0;
    for (int i = 0; i < m + n; i++) {

        if (i == m + n - 1) {
            printf("%d\n", list[i]);
        } else {
            printf("%d", list[i]);
        }
    }
    free(list);
    return 0;
}

